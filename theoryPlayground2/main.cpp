#include <iostream>
using namespace std;

//struct A{
//    uint32_t a;
//    char* ptr;
//    virtual void f();
//    virtual void g();
//};//
//
//struct B{
//    char* ptr;
//    uint32_t x;
//    void g();
//};

//struct Base{
//    int a = 1;
//};
//
//struct Der : Base{
//    int b = 2;
//    int c = 3;
//};
//
//void f(Base*  arr){
//    std::cout<<arr[0].a<< " " << arr[1].a << " "<< arr[2].a << " "<< arr[3].a << " ";
//}
// Der arr[3];
//    f(arr);

//struct A{
//   virtual void f(){cout<<"A::f()";}
//   virtual void g() {cout << "A::g()";}
//
//};
//
//struct B:A{
//     //void f() override{cout<<"B::f()";}
//     void g() override {cout << "B::g()";}
//};
//
//struct C:B{
//    void f() override{
//        cout<<"C::f()";
//    }
//};
//
//struct D:C{

//};
//D obj;
//
//A* ptr1 = &obj;
//B* ptr2 = &obj;
//C* ptr3 = &obj;
//
//ptr1->f();
//ptr2->f();
//ptr3->f();
//
//ptr1->g();
//ptr2->g();
//ptr3->g();

//struct Base{
//    Base(){
//        f();
//    }
//
//    virtual void f(){
//        cout<<"Base::f() ";
//    }
//
//    ~Base(){
//        f();
//    }
//};
//
//
//struct Der:Base{
//    void f() override{
//        cout<<"Der::f() ";
//    }
//};


//void f(unsigned n)
//{
//    int arr[n];// тук размера на масива не е известен по време на компилация
//    cout<<arr[0];
//}
//
//// това е валидно, защото функцията използва шаблон с параметър n, който е константа по време на компилация
//template <unsigned n>
//void g(){
//    int arr[n];//размера на масива е известен по време на компилация
//    std::cout<<arr[0];
//}

//struct A{};
//
//void add(A&& obj, unsigned n)
//{
//       if(data[n] != )
//}

int main() {


}
